const fs = require('fs')
const path = require('path')
const db = require('./db')

const migrationsDir = path.resolve(__dirname, '..', 'migrations')

async function ensureMigrationsTable() {
  await db.query(`
    CREATE TABLE IF NOT EXISTS schema_migrations (
      id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      filename VARCHAR(255) NOT NULL UNIQUE,
      applied_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    )
  `)
}

async function appliedMigrationsSet() {
  const { rows } = await db.query('SELECT filename FROM schema_migrations ORDER BY filename ASC')
  return new Set(rows.map((r) => r.filename))
}

function listMigrationFiles() {
  if (!fs.existsSync(migrationsDir)) return []
  return fs
    .readdirSync(migrationsDir)
    .filter((file) => file.endsWith('.sql'))
    .sort((a, b) => a.localeCompare(b))
}

async function runMigrations() {
  await ensureMigrationsTable()
  const applied = await appliedMigrationsSet()
  const files = listMigrationFiles()

  for (const file of files) {
    if (applied.has(file)) continue

    const fullPath = path.join(migrationsDir, file)
    const sql = fs.readFileSync(fullPath, 'utf8').trim()
    if (!sql) {
      await db.query('INSERT INTO schema_migrations (filename) VALUES ($1)', [file])
      continue
    }

    try {
      await db.query('BEGIN')
      await db.query(sql)
      await db.query('INSERT INTO schema_migrations (filename) VALUES ($1)', [file])
      await db.query('COMMIT')
      console.log(`[migrations] Applied ${file}`)
    } catch (err) {
      await db.query('ROLLBACK')
      console.error(`[migrations] Failed ${file}`, err)
      throw err
    }
  }
}

module.exports = { runMigrations }
